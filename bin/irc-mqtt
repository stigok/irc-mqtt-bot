#!/usr/bin/env node

const MQTT = require('mqtt')
const IRC = require('irc-upd')

const homechan = process.env.HOMECHAN
const botname = process.env.BOTNAME
const mqttserver = process.env.MQTT_CNNSTRING
const ircserver = process.env.IRC_SERVER
const topic = process.env.ROOT_TOPIC

const irc = new IRC.Client(ircserver, botname, {
  'port': 6697,
  'userName': 'sshowbot',
  'realName': `${botname} is a nodebot`,
  'autoConnect': false,
  'channels': [homechan],
  'secure': true,
  'floodProtection': true,
  'floodProtectionDelay': 500
})

const mqtt = MQTT.connect(mqttserver)

mqtt.on('connect', function () {
  mqtt.subscribe(`${botname}/#`)
  console.log('Connected to MQTT server')
})

mqtt.on('message', function (topic, message) {
  message = message.toString()
  console.log(`${topic} -> ${message}`)
  switch (topic) {
    case `${topic}/command/say`:
      irc.say(homechan, message)
      break
    case `${topic}/command/pm`:
      const parts = message.split(' ', 1)
      const nick = parts[0]
      const msg = parts[1]
      if (nick && msg) {
        irc.say(nick, msg)
      }
      break
    case `${topic}/command/setmode`:
      const args = message.split(' ').filter(m => m.length)
      if (args.every(arg => arg.match(/^[+-_a-zA-Z]+$/g))) {
        irc.send('MODE', homechan, ...args)
      }
      break
    case `${topic}/health/test`:
      // Sends a private message to itself to check connection
      irc.say(botname, 'Bot health check ' + Date.now())
      break
    case `${topic}/irc/message/${botname}/${botname}`:
      // Answers private messages from itself with a pong
      mqtt.publish(`${botname}/health/heartbeat`, 'PONG ' + Date.now())
      break
    default:
      // do nothing
      break
  }
})

irc.connect()
irc.addListener('registered', message => {
  console.log('Connected to IRC')
  mqtt.publish(`${topic}/irc/presence`, JSON.stringify(message))
})
irc.addListener('error', err => {
  mqtt.publish(`${topic}/irc/error`, err.toString())
  console.error(err)
})
// irc.addListener('pm', (nick, message) => mqtt.publish(`${topic}/irc/message/${}${nick}`, message))
irc.addListener(`message`, (nick, to, text, message) => {
  mqtt.publish(`${topic}/irc/message/${to}/${nick}`, text)
})

// Allow client to disconnect before terminating the client process
let exitAttempts = 0
function cleanExit () {
  if (exitAttempts === 0) {
    irc.disconnect('wow... actually exiting cleanly', () => console.log('Disonnected from IRC server'))
    mqtt.end(() => console.log('Disconnected from MQTT server'))
    exitAttempts++
  } else {
    console.error('Forcefully exiting...')
    process.exit(1)
  }
}

process.on('SIGINT', () => {
  console.log('SIGINT trapped')
  cleanExit()
})
process.on('SIGHUP', () => {
  console.log('SIGHUP trapped')
  cleanExit()
})
process.on('SIGTERM', () => {
  console.log('SIGTERM trapped')
  cleanExit()
})
